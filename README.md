# 整体介绍

## 项目背景

随着医疗行业的快速发展和公司业务的逐步拓展，我司在各院区部署的设备界面逐渐无法满足院区的定制化需求，传统的开发模式由于页面定制复杂，工期长，人手不够，已经无法满足逐步拓展的需求。低代码开发平台应运而生，它可以帮助用户快速搭建应用，降低开发成本，提高开发效率。医护终端模板定制系统就是一个低代码开发平台，它提供了可视化的界面，用户可以通过拖拽组件的方式快速搭建页面，生成对应的DSL数据，然后设备内通过DSL数据生成实际页面。

## 子包功能介绍

- `llm`: 人工智能模块，封装了大语言模型的对话接口
- `cli`: 命令行工具，脚手架，用于为runtime子包快速链接 `runtime-ui` 的组件
- `core`: 渲染核心，其内部包含了运行时的核心逻辑，如设备适配、尺寸兼容、样式解析、事件处理等
- `designer`: 模板设计器，主要导出了一个Vue组件，用于渲染模板设计器，包含设计器顶部工具栏、左侧组件库、中间画布、右侧属性表单面板等，并封装了这些面板和stage的交互逻辑
- `form`: 表单模块，主要包含了表单组件的渲染逻辑，如输入框、下拉框、单选框、多选框等
- `runtime-ui`: 运行时UI，主要包含了运行时的UI组件，如按钮、文本、图片等，DSL解析出的每一个元素都是一个组件，这些组件都是由 `runtime-ui` 提供的
- `stage`: 设计器舞台，主要包含了编辑器的核心逻辑，内部封装了与runtime的通信逻辑，可通过控制模板上方覆盖的蒙层间接控制runtime的缩放、拖拽、选中、复制、粘贴、删除等
- `schema`: 模板数据结构，主要包含了模板的数据结构定义，如模板、页面、组件、事件、样式等
- `utils`: 工具库，主要包含了一些常用的工具函数，如颜色转换、样式解析、事件处理等
- `playground`: 演示项目，用于演示各个模块的使用方法
- `runtime`: 渲染运行时，用于渲染实际页面，根据DSL生成对应的UI组件树，并暴露出`stage`子包所需的一系列控制方法。

## 核心架构分层是怎样的？

可以将低代码H5模板设计项目分为以下几个核心层次:

### 1. 编辑器层 (Designer Layer)

- **设计器UI (`designer`包)**
  - 顶部工具栏
  - 左侧组件库
  - 中间画布区域
  - 右侧属性配置面板

- **舞台控制层 (`stage`包)**
  - 负责画布交互
  - 拖拽、选中、复制等核心编辑操作
  - 与运行时层通信

### 2. 运行时层 (Runtime Layer)

- **核心运行时 (`core`包)**
  - 设备适配
  - 尺寸兼容
  - 样式解析
  - 事件处理

- **组件运行时 (`runtime-ui`包)**
  - 基础UI组件库
  - 组件生命周期管理
  - 组件间通信

- **渲染运行时 (`runtime`包)**
  - 渲染DSL模板
  - 生成实际页面
  - 与舞台控制层通信

### 3. 数据模型层 (Schema Layer)

- **模板协议 (`schema`包)**
  - DSL(领域特定语言)定义
  - 组件属性描述
  - 页面结构描述
  - 事件系统定义

### 4. 工具支持层 (Utils Layer)

- **开发工具 (`cli`包)**
  - 组件脚手架
  - 开发环境配置

- **通用工具 (`utils`包)**
  - 样式处理
  - 事件工具
  - 通用函数

### 5. 智能增强层 (AI Layer)

- **AI 能力 (`ai`包)**
  - 大语言模型集成
  - 智能代码生成
  - 组件推荐

## 工作流程

1. 设计器层提供可视化界面
2. 通过舞台控制层管理编辑操作
3. 生成DSL模板数据
4. 运行时层同步操作DSL并解析渲染实际页面
5. AI层提供智能辅助能力

## 如何实现多框架（Vue2.7/Vue3/React）的动态渲染？运行时编译方案如何设计？

项目通过模板设计最终产物是DSL数据，它描述了页面的层级结构，样式、事件等信息。运行时层根据DSL数据生成实际页面，所以只需要设计不同框架的DSL解析器，将DSL数据解析为对应框架的组件树即可。

我们提供了基于这三种框架的runtime实现，分别是`runtime-vue2`、`runtime-vue3`、`runtime-react`，它们的核心逻辑是一致的，只是组件的实现方式不同。在设计时，我们将组件的生命周期、props、事件等信息抽象为一个接口，不同框架的组件实现这个接口即可。

## 可视化编辑器的拖拽交互如何实现？如何解决组件层级嵌套、联动通信问题？

1. 设计器层的拖拽交互主要由舞台控制层实现，它负责画布的交互逻辑，如拖拽、选中、复制等操作。

对于拖拽交互，我们主要通过moveable.js实现，它提供了丰富的拖拽交互API，如拖拽、缩放、旋转等。

选中元素主要靠stage中的selectFromPoint实现，通过鼠标点击的坐标，判断点击的元素，然后通过蒙层控制元素的选中状态。

结合moveable.js对选中的元素进行拖拽、缩放等操作，修改设计器层DSL，并同步修改runtime层的DSL。

2. 对于层级嵌套我们也做了特殊处理，例如在拖拽状态下，检测到鼠标在容器元素之上悬停一段事件，将状态切换为 投入容器状态，此时鼠标松开，将元素插入到容器中，并同步修改DSL。

3. 联动通信主要通过core这个子包实现的事件系统完成，我们在DSL中会实现一个特殊的事件对象，这个对象指定了事件的触发条件，如点击、双击、长按等，以及当事件触发时需要联动的组件ID，触发的回调函数，当runtime挂载完成之后，core会为每个dom元素注册指定的事件，当这些dom元素事件触发时，core会找到指定的组件执行其所暴露的方法。

## 设计稿解析（Figma JSON → DSL）的性能瓶颈是什么？如何优化解析速度？

设计稿解析主要是将设计稿的JSON数据解析为DSL数据，将FigmaJSON的树形数据转换成DSL的树形数据，主要的性能瓶颈在于数据结构的转换和逻辑的处理。

1. **数据结构转换**：设计稿的JSON数据结构可能比较复杂，需要将其转换为DSL的数据结构，这个过程可能会涉及到递归、遍历等操作，如果设计稿数据结构过于复杂，可能会导致解析速度变慢。
2. **逻辑处理**：在解析过程中可能需要处理一些逻辑，如组件的嵌套关系、样式的解析、事件的处理等，这些逻辑处理也会影响解析速度。

为了优化解析速度，可以考虑以下几点：

1. **数据结构优化**：设计合理的数据结构，减少不必要的数据转换操作，尽量减少递归、遍历等操作。
2. **逻辑优化**：简化逻辑处理，尽量减少复杂的逻辑判断和处理，提高解析速度。
3. **异步处理**：将解析过程中的耗时操作放到异步任务中处理，避免阻塞主线程，提高解析速度。
4. **缓存优化**：对解析过的数据进行缓存，避免重复解析，提高解析速度。
5. **WebWorker**： 使用WebWorker进行解析，将解析过程放到Worker线程中处理，避免阻塞主线程，提高解析速度。

## 终端多设备渲染如何保证一致性？动态布局方案如何适配不同分辨率？

终端多设备渲染主要通过core这个子包实现的设备适配功能来保证一致性，core会根据设备的分辨率、屏幕尺寸等信息，动态调整页面的布局，保证在不同设备上显示效果一致。

具体步骤如下：

1. 通过设计图的固定尺寸来搭建页面，如床头机的设计图尺寸为1024 *600，那么最终产出的DSL模板尺寸即为 1024* 600。
2. 设备渲染runtime时，core结合DSL提供的模板尺寸和设备的分辨率计算出缩放比例
2. runtime解析DSL组件样式时，会根据缩放比例动态调整组件的尺寸、位置等样式，保证在不同设备上显示效果一致。

## 为什么runtime不使用REM的方案？

业内主流的移动端REM适配方案是根据设备的dpr和屏幕宽度动态计算根元素的font-size，然后使用rem作为单位，实现页面的自适应。

这对于对屏幕高度要求不高的H5页面是一个不错的方案，但是对于我们多分辨率、多设备的系统来说，REM方案存在一些问题：

1. 在需要将模板铺满整个屏幕的场景下，REM方案在不同分辨率下的表现不够理想，因为REM是根据屏幕宽度计算的，如1024 *600 的设计稿，分成32等分，根元素大小为32px, 那么实际页面中，屏幕宽度是 32rem，高度则是 18.75rem，一般来说这个数值在模板下发之后是保持不变的，那么问题就来了，此情况在分辨率为 1920* 1080 的设备上，根元素大小为 60px，实际页面高度为 60 *18.75 = 1125px，页面会出现滚动条。 在分辨率为 1280* 800 的设备上，根元素大小为 40px，实际页面高度为 40 * 18.75 = 750px，页面则会出现白边。

综合考虑上述因素，最终选择了使用px作为单位：

1. **设计稿的固定尺寸**：设计稿的尺寸是固定的，如1024 * 600，使用px作为单位更符合设计稿的尺寸，方便计算。
2. **设备适配**：使用px作为单位，可以更方便的进行设备适配，通过计算缩放比例，动态调整组件的尺寸、位置等样式。
3. **开发便捷**：使用px作为单位，更符合前端开发的习惯，开发便捷。

## 大语言模型（LLM）集成后，如何控制推理延迟？是否做过模型轻量化？

## Monaco Editor 在低代码场景下的定制化改造点有哪些？（如代码提示、DSL 校验）

代码提示、DSL校验

## Moveable/Gesto 库在拖拽中的使用遇到过哪些坑？如何解决组件边界计算问题？

moveable初始化配置中有一个bounds对象，用于限制被moveable操控对象的位移量，当left设置0的时候其位移始终无法设置为0，只能设置为-1

## TurboRepo 在 Monorepo 管理中的具体分工策略？如何解决包之间的循环依赖？

本项目采用的是pnpm的Monorepo单仓管理策略，pnpm通过工作空间协议建立子包之间的链接，而turboRepo的并行构建和构建缓存则能够保证项目的开发和构建能够保持在一个较高效率下执行。

如果工作空间依赖项之间存在循环，则 pnpm 无法保证脚本将按拓扑顺序运行。 如果 pnpm 在安装过程中检测到循环依赖，则会提供一个 warning 警告。 如果 pnpm 能够找出导致循环的依赖项，也会将其展示出来。
